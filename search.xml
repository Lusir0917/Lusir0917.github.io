<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20210330更新日志</title>
    <url>/2021/03/30/21-06-17/</url>
    <content><![CDATA[<p> 1.标签和分类页面可以进去了</p>
<p>2.添加<del>超级卡哇伊的</del>头像</p>
<p>3.删除掉无用的about（以后可能有用）</p>
<p>其他博文还在路上</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210331更新日志</title>
    <url>/2021/03/31/19-33-55/</url>
    <content><![CDATA[<p>1.添加搜索功能</p>
<p>2.在“关于”界面内增加了简介</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210401更新日志</title>
    <url>/2021/04/01/21-08-26/</url>
    <content><![CDATA[<p>1.底部添加点击量（貌似有点小问题？）</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210403更新日志</title>
    <url>/2021/04/03/23-44-58/</url>
    <content><![CDATA[<p>1.增加底部字数统计</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210406更新日志</title>
    <url>/2021/04/06/23-04-49/</url>
    <content><![CDATA[<p>1.现在背景有奇怪的动态折线了</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210410更新日志</title>
    <url>/2021/04/10/23-53-08/</url>
    <content><![CDATA[<p>1.头像可以转动了，而且变圆了</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210413更新日志</title>
    <url>/2021/04/13/23-37-43/</url>
    <content><![CDATA[<p>1.社交链接改成github了。</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210417更新日志</title>
    <url>/2021/04/17/23-28-15/</url>
    <content><![CDATA[<p>1.文章内的链接样式更改，会变色了，虽然还没有链接</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>20210422更新日志</title>
    <url>/2021/04/22/21-59-08/</url>
    <content><![CDATA[<p>1.增加了音乐播放器，目前只有一首，后续会调整为歌单。</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>ABB(manacher)</title>
    <url>/2021/04/08/23-10-06/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Fernando was hired by the University of Waterloo to finish a development project the university started some time ago. Outside the campus, the university wanted to build its representative bungalow street for important foreign visitors and collaborators.<br>Currently, the street is built only partially, it begins at the lake shore and continues into the forests, where it currently ends. Fernando’s task is to complete the street at its forest end by building more bungalows there. All existing bungalows stand on one side of the street and the new ones should be built on the same side. The bungalows are of various types and painted in various colors.<br>The whole disposition of the street looks a bit chaotic to Fernando. He is afraid that it will look even more chaotic when he adds new bungalows of his own design. To counterbalance the chaos of all bungalow shapes, he wants to add some order to the arrangement by choosing suitable colors for the new bungalows. When the project is finished, the whole sequence of bungalow colors will be symmetric, that is, the sequence of colors is the same when observed from either end of the street.<br>Among other questions, Fernando wonders what is the minimum number of new bungalows he needs to build and paint appropriately to complete the project while respecting his self-imposed<br>bungalow color constraint.</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line contains one integer N (1 ≤ N ≤ 4 ×105 ), the number of existing bungalows in the street. The next line describes the sequence of colors of the existing bungalows, from the beginning of the street at the lake. The line contains one string composed of N lowercase letters (“a” through “z”), where different letters represent different colors.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Output the minimum number of bungalows which must be added to the forest end of the street and painted appropriately to satisfy Fernando’s color symmetry demand.</p>
<h4 id="样例输入-Copy"><a href="#样例输入-Copy" class="headerlink" title="样例输入 Copy"></a>样例输入 <a href="javascript:CopyToClipboard($('#sampleinput').text())">Copy</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">abb</span><br></pre></td></tr></table></figure>

<h4 id="样例输出-Copy"><a href="#样例输出-Copy" class="headerlink" title="样例输出 Copy"></a>样例输出 <a href="javascript:CopyToClipboard($('#sampleoutput').text())">Copy</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>本题是求最少加几个字符可以使该串变成回文串，那么很显然使用马拉车定理求出可以延伸到末尾的回文串再加上其坐标即可，关于manacher 定理敬请查看我上一篇博文 。 </p>
<p>下面贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span>  t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> ;</span><br><span class="line"><span class="keyword">char</span> str[ N + <span class="number">10</span> ] ;</span><br><span class="line"><span class="keyword">char</span> ns[ <span class="number">2</span>*N + <span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> r[<span class="number">2</span> *N +<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_change</span><span class="params">(<span class="keyword">char</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ns[<span class="number">0</span>] = <span class="string">&#x27;@&#x27;</span> ;</span><br><span class="line">    ns[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        ns[<span class="number">2</span>*i + <span class="number">2</span>] = a[i] ;</span><br><span class="line">        ns[<span class="number">2</span>*i + <span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ns[<span class="number">2</span>*len + <span class="number">2</span>] = <span class="string">&#x27;$&#x27;</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span> ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span> ,maxid = <span class="number">0</span> ;</span><br><span class="line">    len = <span class="number">2</span> * len + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++)</span><br><span class="line">    &#123;     <span class="keyword">if</span>(maxid &gt; i )</span><br><span class="line">        r[i] = <span class="built_in">min</span>(r [<span class="number">2</span> * id - i] , maxid - i ) ;</span><br><span class="line">        <span class="keyword">else</span> r[i] = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(ns[i + r[i]] ==ns [ i - r[i]] )</span><br><span class="line">        r[i] ++ ;</span><br><span class="line">    <span class="keyword">if</span>(r[i] + i &gt; maxid)</span><br><span class="line">    &#123;</span><br><span class="line">        maxid = r[i] + i ;</span><br><span class="line">        id = i ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">1</span> ; j &gt;=<span class="number">0</span>  ; j --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(r[j] + j == len )</span><br><span class="line">           ans = <span class="built_in">min</span>(ans,t - r[j] + <span class="number">1</span> ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len) ;</span><br><span class="line">t = len;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str) ;</span><br><span class="line"><span class="built_in">pre_change</span>(str) ;</span><br><span class="line"><span class="comment">//puts(ns) ;</span></span><br><span class="line"><span class="built_in">manacher</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>20210427更新日志</title>
    <url>/2021/04/27/22-09-51/</url>
    <content><![CDATA[<p>1.现在音乐换成我的歌单了，但是由于宽度限制导致按钮重叠，不过还是能点到的，后续会解决</p>
]]></content>
      <categories>
        <category>更新日志</category>
      </categories>
  </entry>
  <entry>
    <title>Et Tu Brute?</title>
    <url>/2021/04/11/21-52-12/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Caesar has been betrayed! He always thought his best friends were the senators of Rome, but it turns out they are trying to kill him. Even his best friend, Marcus Junius Brutus, is in on the plot. Luckily, he’s managed to get away, for now. If he can make it out of the senate he’ll be okay, and he can overthrow the senate and take over Rome.<br>Unfortunately, he’s a little rattled, and is not making smart decisions. Every minute, he is randomly choosing which room he enters and hides in for the next minute. In each room there is a p% chance that he will be captured. After m minutes the senators will give up the search and go back to their homes, allowing him to escape. Calculate the chance that he will escape if he chooses rooms at random.</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line of the input will be a single integer, n ≤ 1, 000. There will be n test cases that follow.<br>Each test case will start with a line of 2 integers: the number of rooms 5 ≤ r ≤ 50 and the number of minutes Caesar must survive, m ≤ 10. The next r lines will consist of a floating point number p &lt; 1 denoting the probability that Caesar survives for the next minute in this room and 4 integers between 1 and r (inclusive on both ends) denoting which rooms the current room is connected to. Caesar always spends the first minute in room 1.<br>Note: The senate is weird, just because room a leads to room b does not mean Caesar can get back into room a from room b.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Output a single floating point number denoting the probability that Caesar survives. The output should be accurate and truncate to three decimal places.</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 3</span><br><span class="line">0.50 2 3 4 5</span><br><span class="line">0.25 1 3 4 5</span><br><span class="line">0.30 1 2 4 5</span><br><span class="line">0.80 1 2 3 5</span><br><span class="line">0.60 1 2 3 4</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.113</span><br></pre></td></tr></table></figure>

<p>样例大意是给定有5个房间，按顺序给出，凯撒需要存活3分钟，后面按1到5的顺序分别给出了其存活概率以及该房间通向的四个房间，不可逆向。</p>
<p>显然这是一道简单的概率题，其向多条路并且有终点的性质，显然容易想到递归，并且递归的终点就是时间到了3分钟 ，再加上其总共会给出四个房间，最后算出来的概率还需要/4</p>
<p>下面贴出AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> probs[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> rooms[<span class="number">55</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ( <span class="built_in">dfs</span>(m<span class="number">-1</span>, rooms[id][<span class="number">1</span>])</span><br><span class="line">              + <span class="built_in">dfs</span>(m<span class="number">-1</span>, rooms[id][<span class="number">2</span>])</span><br><span class="line">              + <span class="built_in">dfs</span>(m<span class="number">-1</span>, rooms[id][<span class="number">3</span>])</span><br><span class="line">              + <span class="built_in">dfs</span>(m<span class="number">-1</span>, rooms[id][<span class="number">4</span>]) ) / <span class="number">4</span> * probs[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> r, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;m) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">&quot;%lf%d%d%d%d&quot;</span>,probs + i , rooms[i] + <span class="number">1</span> ,rooms[i] +<span class="number">2</span> , rooms[i] + <span class="number">3</span> ,rooms[i] + <span class="number">4</span> ) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, <span class="built_in">dfs</span>(m, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>面对这种多个相同过程并且有相似的终点题目，应该首先联想到递归！</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Jump Conveyor(图论)</title>
    <url>/2021/04/14/21-01-28/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Emma is a creative child who got bored during the quarantine season. She set up n trampolines in a line inside the living room, each aimed in a particular direction. The ith trampoline has value vi.<br>When Emma jumps to position i, if there is a trampoline, she will jump to position i+vi. Of course, this could result in infinite jumping. </p>
<p>The Problem<br>Emma’s younger brother, Oliver, is very concerned for his sister’s safety. He would like to determine how many trampolines are unsafe for Emma to jump on initially. A trampoline is unsafe if it leads to infinite jumping. </p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line of input will contain a single positive integer, t (t≤ 20), representing the number of input cases to process. The input cases follow. The first line of each input case contains a single<br>positive integer, n(1 ≤ n ≤ 1,000,000) representing the number of trampolines. Then, a single line follows with n integers, the values |vi| ≤ 109 for each trampoline.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>For each case, output a single line with a single integer representing the answer to the input case. </p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br><span class="line">1 -2 3 -1 2 -2 -2 </span><br><span class="line">5 </span><br><span class="line">4 2 5 -1 -3 </span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>题目jump -conveyor 翻译为跳出传送带，拿第一组数据举例</p>
<p>可以选择7个点（位置1-n)中的某一个点x进入“传送带”，能跳到的下一个位置是x+a[i] ; </p>
<p>问有几个点是跳不出去的死循环点。</p>
<p>本题限时5s.</p>
<p><strong>思路一</strong>：对每个点递推位置，若回到了起点，表明该点是个循环点。</p>
<p>于是这样做就超时了。</p>
<p><strong>思路二</strong>：利用图论，标记能成环的点，若沿着某个点搜索到一个能成环的点，则该点最终必能成环，即跳不出去。</p>
<p>这种思路有效利用了其他成环的点，从而节省了大量的重复运算而提升时间效率。</p>
<p>搜索终止的条件有4点：</p>
<ol>
<li><p>跳出去了，于是直接标记此点不成环</p>
</li>
<li><p>回到起点，于是标记该点能成环</p>
</li>
<li><p>碰到能成环的点，于是仍标记该点能够成环</p>
</li>
<li><p>碰到跳出去的点，于是标记该点最终能够跳出</p>
<p>其中3,4可以理解为沿着x往下搜索，并同时为x赋值</p>
<p>用flag [x]来标记x点成环的情况，若x点成环则标记为1，否则为0 ； </p>
<p>于是我终于看懂了大佬的AC代码，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],vis[N],flag[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> vn,<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//x代表从x开始搜索，vn代表搜索的起点，n是外界</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">1</span> || x &gt; n) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//搜索过界表明碰到了端点，标记该点为不成环的点</span></span><br><span class="line">    <span class="keyword">if</span>(flag[x]!=<span class="number">-1</span>) <span class="keyword">return</span> flag[x];<span class="comment">//搜索途中遇见了一个环或者能跳出的点，于是为其赋值</span></span><br><span class="line">    <span class="keyword">if</span>(vis[x]==vn) <span class="keyword">return</span> flag[x]=<span class="number">1</span>;<span class="comment">//搜索后到了起点，表明这是一个环，于是该点处可以成环</span></span><br><span class="line">    vis[x]=vn;<span class="comment">//用vis标记搜过的点是从起点vn搜索的</span></span><br><span class="line">    <span class="keyword">return</span> flag[x]=<span class="built_in">dfs</span>(x+a[x],vn,n);<span class="comment">//沿着x向下找环并且顺带给x点是否有环进行赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            vis[i]=flag[i]=<span class="number">-1</span>;<span class="comment">//vis标记从某个点走过，flag标记该点能否成环</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i,i,n);</span><br><span class="line">            ans+=flag[i];<span class="comment">//若i能成环，则ans ++ ；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Marching Legion(BFS)</title>
    <url>/2021/04/12/23-34-49/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>There’s a rebellion in Antioch! Caesar is preparing to dispatch an entire legion of his best troops to quell the rebellion, but before he does, he wants to make certain the legion will make it to Antioch.<br>Along the way, there are mountains, rivers, seas, and mythical monsters, each of which the legion cannot pass through. Given a map a legion must travel through, find out if the legion can reach Antioch from Rome.</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line of the input will be a single integer, n ≤ 1, 000. There will be n test cases that follow.<br>Input will begin with two integers, 0 &lt; h, w &lt; 100, indicating the height and width of the map, respectively. h lines with w characters each will follow. An “X” on the map represents an impassable obstacle while an “O” represents traversable terrain. Note that legions, moving in square formations, can only move up, down, left, and right; legions can never travel diagonally. “R” represents Rome, the starting point of the legion, and “A” represents Antioch, the destination point for the legion</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Output “March onward!” if the legion can reach Antioch from Rome, “Stay home!” otherwise. Each output should be line separated.</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6 6</span><br><span class="line">XXXXOA</span><br><span class="line">XOXXOX</span><br><span class="line">XOXXOX</span><br><span class="line">XOOOOX</span><br><span class="line">XOXXXX</span><br><span class="line">XROOOX</span><br><span class="line">4 4</span><br><span class="line">XXOA</span><br><span class="line">XOOX</span><br><span class="line">XOXX</span><br><span class="line">XRXO</span><br><span class="line">2 2</span><br><span class="line">XA</span><br><span class="line">RX</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">March onward!</span><br><span class="line">March onward!</span><br><span class="line">Stay home!</span><br></pre></td></tr></table></figure>

<p>题目大意为给定起始点A终点R，其中X不能通，O可通过，问能否到达终点，寻路问题上能用BFS就不用DFS，这是一道简单的BFS题目。详情请看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="keyword">int</span> t ;<span class="comment">//记录数据的数量</span></span><br><span class="line"><span class="keyword">int</span> R,C ;<span class="comment">//分别为区域的长宽</span></span><br><span class="line"><span class="keyword">char</span> pos[<span class="number">110</span>][<span class="number">110</span>] ;<span class="comment">//存储目标位置</span></span><br><span class="line"><span class="keyword">int</span> mov[<span class="number">5</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125; ;<span class="comment">//使用位移数组，减少码量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//结构体记录位置</span></span><br><span class="line">    <span class="keyword">int</span> x  ;</span><br><span class="line">    <span class="keyword">int</span> y ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> start_x,start_y, end_x,end_y ;</span><br><span class="line">queue&lt;node&gt;q ;<span class="comment">//使用队列存储起点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//判断此路是否可通</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;=<span class="number">1</span> &amp;&amp; x &lt;= R&amp;&amp;y &gt;= <span class="number">1</span> &amp;&amp; y &lt;=C&amp;&amp;(pos[x][y] == <span class="string">&#x27;O&#x27;</span>||pos[x][y] ==<span class="string">&#x27;R&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())q.<span class="built_in">pop</span>() ;<span class="comment">//清空队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;start_x,start_y&#125;) ;<span class="comment">//起点入队</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> X = q.<span class="built_in">front</span>().x ;<span class="comment">//开始从队首的一个路口走起</span></span><br><span class="line">        <span class="keyword">int</span> Y = q.<span class="built_in">front</span>().y ;</span><br><span class="line">        q.<span class="built_in">pop</span>() ;<span class="comment">//不回头哈哈哈</span></span><br><span class="line">        <span class="keyword">if</span>(X == end_x &amp;&amp; Y == end_y) <span class="keyword">return</span> <span class="number">1</span> ;<span class="comment">//到终点就返回1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i ++ )&#123;</span><br><span class="line">            <span class="keyword">int</span> next_x,next_y ;</span><br><span class="line">            next_x = X + mov[i][<span class="number">0</span>] ;</span><br><span class="line">            next_y = Y + mov[i][<span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">judge</span>(next_x,next_y))&#123;<span class="comment">//判断四个方向能否走</span></span><br><span class="line">                pos[next_x][next_y] = <span class="string">&#x27;X&#x27;</span> ;<span class="comment">//不再回头，直升起点</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;next_x,next_y&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t) ;</span><br><span class="line">    <span class="keyword">while</span>(t -- )&#123;</span><br><span class="line">        start_x = <span class="number">0</span> ;</span><br><span class="line">        start_y = <span class="number">0</span> ;</span><br><span class="line">        end_y = <span class="number">0</span> ;</span><br><span class="line">        end_x = <span class="number">0</span> ;</span><br><span class="line">        cin&gt;&gt; R &gt;&gt; C ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= R ; i ++ )</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= C ; j ++ )&#123;</span><br><span class="line">                cin &gt;&gt; pos[i][j] ;</span><br><span class="line">                <span class="keyword">if</span>(pos[i][j] == <span class="string">&#x27;A&#x27;</span>)&#123;<span class="comment">//找到起始位置</span></span><br><span class="line">                    start_x =  i ;</span><br><span class="line">                    start_y = j   ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pos[i][j] == <span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                    end_x = i ;</span><br><span class="line">                    end_y = j ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bfs</span>()) <span class="built_in">puts</span>(<span class="string">&quot;March onward!&quot;</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Stay home!&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对比DFS会走到很多的死路并且回溯会导致时间效率过低，而BFS会对所有岔路进行检索，并且不会回头，所以解决这类问题BFS优先于DFS 。</p>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>QUEEN COVERAGE</title>
    <url>/2021/04/20/23-12-44/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>In chess, a queen can move as many spaces as she wants in any of the eight directions: up, down, left, right, up and left, up and right, down and left, and down and right, so long as there are no other pieces in her way. </p>
<p>The Problem<br>Given a large chess board with several queens placed on it, how many squares on the board are either occupied by a queen or can be attacked directly by a queen? (Another way of thinking of the question is: how many squares on the board are already occupied by queens or could have a queen after one move by a queen?) </p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line of input will contain a single positive integer, n (n ≤ 20), representing the number of input cases to process. The input cases follow. </p>
<p>The first line of each input case contains two space separated positive integers, s (3 ≤ s ≤ 2000) and q (0 ≤ q ≤ 2000), representing the size of the chess board (both the number of rows and columns) and the number of queens placed on the board, respectively. Then, there will be q lines, each with two space separated integers, xi and yi (1 ≤ xi , yi ≤ s) representing the row and column of the ith queen. </p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>For each case, output a single line with a single integer representing the answer to the input case. </p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1</span><br><span class="line">1 3</span><br><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">14</span><br></pre></td></tr></table></figure>

<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定固定大小的棋盘，给定指定数量的皇后的位置，问皇后能吃到的位置加上皇后占的位置一共有多少个 。 </p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题有坑，其数据看似很大，实际上暴力模拟就能过了，不过部分地方处理有借鉴价值 。</p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> team;</span><br><span class="line"><span class="keyword">int</span> size,n,x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">bool</span> line[],<span class="keyword">bool</span> hen[],<span class="keyword">bool</span> zhu[],<span class="keyword">bool</span> ci[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> start=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=size; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(line[i]) &#123;</span><br><span class="line">			ans+=size;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=start; j&lt;=size; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(zhu[i-j+size]||ci[i+j<span class="number">-1</span>]||hen[j]) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;team) ;</span><br><span class="line">	<span class="keyword">while</span>(team--) &#123;</span><br><span class="line">		<span class="keyword">bool</span> line[<span class="number">2010</span>]= &#123;<span class="literal">false</span>&#125;,hen[<span class="number">2010</span>] = &#123;<span class="literal">false</span>&#125;,zhu[<span class="number">4000</span>]= &#123;<span class="literal">false</span>&#125;,ci[<span class="number">4000</span>]= &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;size,&amp;n) ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y) ;</span><br><span class="line">			<span class="keyword">if</span>(!line[x]) </span><br><span class="line">            line[x]=<span class="literal">true</span>;<span class="comment">//标记能被吃的横坐标</span></span><br><span class="line">			<span class="keyword">if</span>(!hen[y]) <span class="comment">//标记能被吃的纵坐标</span></span><br><span class="line">            hen[y]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(!zhu[x-y+size]) <span class="comment">//标记经过该点的主对角线</span></span><br><span class="line">            zhu[x-y+size]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ci[x+y<span class="number">-1</span>]) <span class="comment">//标记经过该点的次对角线</span></span><br><span class="line">            ci[x+y<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">work</span>(size,line,hen,zhu,ci)) ;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>ROAD(DFS)</title>
    <url>/2021/04/18/22-45-52/</url>
    <content><![CDATA[<h4 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>N cities named with numbers 1 … N are connected with one-way roads. Each road has two parameters associated with it : the road length and the toll that needs to be paid for the road (expressed in the number of coins).<br>Bob and Alice used to live in the city 1. After noticing that Alice was cheating in the card game they liked to play, Bob broke up with her and decided to move away - to the city N. He wants to get there as quickly as possible, but he is short on cash.<br>We want to help Bob to find the shortest path from the city 1 to the city N that he can afford with the amount of money he has.</p>
<h4 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h4><p>The first line of the input contains the integer K, 0 &lt;= K &lt;= 10000, maximum number of coins that Bob can spend on his way.<br>The second line contains the integer N, 2 &lt;= N &lt;= 100, the total number of cities.<br>The third line contains the integer R, 1 &lt;= R &lt;= 10000, the total number of roads.<br>Each of the following R lines describes one road by specifying integers S, D, L and T separated by single blank characters :<br>S is the source city, 1 &lt;= S &lt;= N<br>D is the destination city, 1 &lt;= D &lt;= N<br>L is the road length, 1 &lt;= L &lt;= 100<br>T is the toll (expressed in the number of coins), 0 &lt;= T &lt;=100<br>Notice that different roads may have the same source and destination cities.</p>
<h4 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h4><p>The first and the only line of the output should contain the total length of the shortest path from the city 1 to the city N whose total toll is less than or equal K coins.<br>If such path does not exist, only number -1 should be written to the output.</p>
<p>例如:</p>
<table>
<thead>
<tr>
<th align="left">输入</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>5 6 7 1 2 2 3 2 4 3 3 3 4 2 4 1 3 4 1 4 6 2 1 3 5 2 0 5 4 3 2 </code></td>
<td align="left"><code>11 </code></td>
</tr>
</tbody></table>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>本题给定了目标城市N ，并且给出了各个城市的终点城市，路程，以及花费，我们需要在花费不高于K的情况下找到去到城市N的最短路程 。 </p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题的深度搜索思路不难，回溯时剪枝即可，但是<u>怎么遍历给出的所有路是关键，怎么从一个城市到另一个城市，又能在另一个城市的各条路上进行搜索成为了难点</u>。我们试着对每一条路的父节点进行标记，用一个数组存储该城市父节点的下标就可以实现上述目标，详情见代码。 </p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y ;&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">110</span>] ;</span><br><span class="line"><span class="keyword">int</span> fis[<span class="number">110</span>] ;</span><br><span class="line"><span class="keyword">int</span> mi = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fuck</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d ;<span class="comment">//d记录该城市的终点</span></span><br><span class="line">    <span class="keyword">int</span> l ;<span class="comment">//l记录距离</span></span><br><span class="line">    <span class="keyword">int</span> dad ;<span class="comment">//记录当前城市的父节点</span></span><br><span class="line">    <span class="keyword">int</span> cost ;<span class="comment">//cost记录花费</span></span><br><span class="line">&#125;cnm[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> k , n, r ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> q ,<span class="keyword">int</span> p ,<span class="keyword">int</span> k )</span><span class="comment">//q是城市的起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q == n )<span class="comment">//到达目标城市，更新花费</span></span><br><span class="line">    mi = <span class="built_in">min</span>(p,mi) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = fis[q]; i != <span class="number">-1</span> ; i = cnm[i].dad)<span class="comment">//i为到达该城市的最后一条路（方式），i=-1表示已经没有更多的路了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意初始化的i是q城市父节点，也就是上个城市，说白了i城市的终点就是q，</span></span><br><span class="line">        <span class="comment">//通过这种方式可以找到到达q的所有路径</span></span><br><span class="line">        <span class="keyword">int</span> d = cnm[i].d ;<span class="comment">//i城市的终点</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[d] &amp;&amp; cnm[i].l +p  &lt;mi &amp;&amp; k - cnm[i].cost &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">            vis[d] = <span class="number">1</span> ;</span><br><span class="line">            <span class="built_in">dfs</span>(d,cnm[i].l+ p ,k - cnm[i].cost) ;</span><br><span class="line">            vis[d] = <span class="number">0</span> ;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;n,&amp;r) ;</span><br><span class="line"><span class="built_in">memset</span>(fis,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(fis)) ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; r ; i ++ )&#123;</span><br><span class="line">    <span class="keyword">int</span>  s, d, l, t ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;s,&amp;d,&amp;l,&amp;t) ;</span><br><span class="line">    cnm[i].d = d ;<span class="comment">//destination记录当前城市的终点</span></span><br><span class="line">    cnm[i].l = l ;<span class="comment">//len记录距离</span></span><br><span class="line">    cnm[i].cost =  t ;<span class="comment">//花费</span></span><br><span class="line">    cnm[i].dad = fis[s] ;<span class="comment">//记录当前点的父节点的下标</span></span><br><span class="line">    fis[s] = i ;<span class="comment">//更新该点的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,k) ;</span><br><span class="line"><span class="keyword">if</span>(mi!=<span class="number">0x3f3f3f3f</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mi) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结： 搜索的本质是对图的遍历，借助图的知识，可以很有效的解决一些问题。 </p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>STICKS(DFS)</title>
    <url>/2021/04/19/21-48-26/</url>
    <content><![CDATA[<h4 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero.</p>
<h4 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h4><p>The input contains blocks of 2 lines. The first line contains the number of sticks parts after cutting, there are at most 64 sticks. The second line contains the lengths of those parts separated by the space. The last line of the file contains zero.</p>
<h4 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h4><p>The output should contains the smallest possible length of original sticks, one per line.</p>
<p>例如:</p>
<table>
<thead>
<tr>
<th align="left">输入</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>9 5 2 1 5 2 1 5 2 1 </code></td>
<td align="left"><code>6 </code></td>
</tr>
<tr>
<td align="left"><code>4 1 2 3 4 0 </code></td>
<td align="left"><code>5</code></td>
</tr>
</tbody></table>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>话说这个人有若干根长度相等的木棍，然后他把木棍全随机打碎了，由于他的记性不好，忘记了打碎前这些木棍的长度，现在给定其打碎后的各个小木棍的长度，求其打碎前各个木棍的最小可能长度 。 </p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题的难点在于搜索的方式与剪枝，根据其木棍被打碎前每根长度都相等，我们需要搜索一个目标长度len，看剩下的碎片能否拼出这个len，能就继续搜索，直到所有的碎片都被用完并且都拼成了长度为len 的木棍。 因此dfs的状态中就需要有目标长度len，还需要的长度， 剩下小木棍的的数量。 现在明确需要的条件：</p>
<ol>
<li>len一定大于碎片中最长的，并且小于这些碎片拼起来的总长度sum</li>
<li>sum % len == 0 ，可以在枚举len时直接判断</li>
<li>一个碎片若不能与len进行拼接，则与其相等的碎片也不能（这里就需要一个排序了）</li>
</ol>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n ,sum,ma;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">70</span>] ;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">64</span> *<span class="number">50</span> + <span class="number">6</span>] ;<span class="comment">//标记a[i]是否使用过</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">int</span> d ,<span class="keyword">int</span> rest )</span><span class="comment">//d记录还需要拼接的长度，rest记录剩下碎片的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span> &amp;&amp; rest == <span class="number">0</span> )<span class="keyword">return</span> len ;<span class="comment">//没有剩下的木棍碎片，并且还需要拼接的长度为0，说明找到了</span></span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">0</span> )d = len ;<span class="comment">//d=0开始拼一个新的长度为len的木棍</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d &gt;= a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = <span class="number">1</span> ;<span class="comment">//选择当前碎片进行拼接</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(len,d - a[i],rest - <span class="number">1</span>)) <span class="keyword">return</span> len ;</span><br><span class="line">                vis[i] = <span class="number">0</span> ;<span class="comment">//回溯</span></span><br><span class="line">                <span class="keyword">if</span>(a[i] == d || len ==  d ) <span class="keyword">break</span> ;<span class="comment">//要拼接的碎片和len一样长，就说明找不到</span></span><br><span class="line">                <span class="keyword">while</span>(a[i] == a[i+<span class="number">1</span>])</span><br><span class="line">                    i ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ ) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a + i ) ;</span><br><span class="line">    sum += a[i] ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">sort</span>(a , a +n , greater&lt;<span class="keyword">int</span>&gt;())  ;<span class="comment">//从大到小排序</span></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = a[<span class="number">0</span>] ; i &lt;= sum ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis)) ;</span><br><span class="line">    <span class="keyword">if</span>(sum % i == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">dfs</span>(i,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">if</span>(ans)<span class="keyword">break</span> ;<span class="comment">//第一个找到的答案就是最小的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结：dfs的搜索方式是重点。"><a href="#总结：dfs的搜索方式是重点。" class="headerlink" title="总结：dfs的搜索方式是重点。"></a>总结：dfs的搜索方式是重点。</h4>]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Unraveling Monty Hall(思维)</title>
    <url>/2021/04/26/21-44-06/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>On the stage of an auditorium program there are three closed doors: door 1, door 2 and door 3. Behind one of these doors there is a car and behind the other two doors there is a goat. The production of the program randomly chooses the door where the car is without cheating. Only the host of the program knows where the car is. He asks the player to choose one of the doors. We can see that, because there is only one car, and at at least one of the two doors that the player did not choose, there has to be a goat!</p>
<p>Therefore, the presenter can always do the following: between the two doors that the Player did not choose, he opens one that has a goat, so that the player and the spectators can see the goat. The presenter now asks: “Do you want to change your door to the other door that is still closed?”. Is it a beneficial change or not? The player wants to stay with the door that has the car, of course!</p>
<p>Paulinho saw a rigorous demonstration that the odds of the car being behind door the player chose initially is 13 and the odds of the car being behind the other door which is still closed and the player did not choose initially is 23 and therefore the exchange is advantageous. Paulinho doesn’t conform, his intuition tells him that either way, the probability is 12 for both doors still closed.</p>
<p>To bring this matter to an end, let’s simulate this game thousands of times and count how many times the player won the car. We will assume that:<br>·The player picks door 1 initially;<br>·The player always changes doors after the presenter reveals a goat by opening one of the two doors that were not initially selected.<br>In these conditions, in a game, given the number of the door that contains the car, we can know exactly whether the player will win the car or not.</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line of the input contains an integer N (1≤N≤104), indicating the number of games in the simulation. Each of the N following rows contains an integer: 1, 2 or 3; representing the door number containing the car in that game.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Your program must produce a single line containing an integer representing the number of times the player won the car in this simulation, assuming that he always chooses the door 1 and always switch doors after the host reveals a goat by opening one of the two doors that were not initially selected.</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>该问题就是典型的三门问题，大意是有三扇门，1,2,3，分别有两头羊和一辆汽车藏于门后，刚开始你可以指定要打开一扇门，但这个时候主持人会将另外两扇门中一扇有羊的门打开，并且询问你要不要换另一个门打开。正解应该是要换。原因很简单，当主持人展示了一扇有羊的门时，此时能否打开有汽车的那扇门取决于换与不换，若不换，当前门后有汽车的概率是1/3（因为另外两门至少有一只羊，所以展示其中的一个不会影响当前门后是否有汽车），因此不换获得汽车的概率就是1/3，由事件的对立性可知，更换获得汽车的概率即为2/3，而不是1/2。</p>
<p>本题中给出了汽车的位置（1,2,3）门，然后主人公总会选择第1扇门并且在主持人询问是否要更换时一定会更换。</p>
<p>询问主人公能赢得多少次汽车</p>
<p>结合上述可知若汽车就在1门后，更换后一定不能得到汽车，反之一定能得到汽车，换言之本题就是统计2,3的数量</p>
<p>于是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(temp !=<span class="number">1</span>)ans ++ ;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>WIFI SETUP(DP)</title>
    <url>/2021/04/15/22-10-51/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>Farmer John’s N cows (1 &lt;= N &lt;= 2000) are all standing at various positions along the straight path from the barn to the pasture, which we can think of as a one-dimensional number line. Since his cows like to stay in email<br>contact with each-other, FJ wants to install Wifi base stations at various positions so that all of the cows have wireless coverage.</p>
<p>After shopping around, FJ learns that the cost of a Wifi base station depends on distance it can transmit: a base station of power r costs A + B*r, where A is a fixed cost for installing the base station and B is a cost per unit of transmission distance. If FJ installs such a device at position x, then it can transmit data to any cow located in the range x-r … x+r. A base station with transmission power of r=0 is allowed, but this only provides coverage to a cow located at the same position as the transmitter.</p>
<p>Given the values of A and B, as well as the locations of FJ’s cows, please determine the least expensive way FJ can provide wireless coverage for all his cows.</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>* Line 1: Three space-separated integers: N A B (0 &lt;= A, B &lt;= 1000).<br>* Lines 2..1+N: Each line contains an integer in the range 0..1,000,000 describing the location of one of FJ’s cows.</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>* Line 1: The minimum cost of providing wireless coverage to all cows.</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 20 5</span><br><span class="line">7</span><br><span class="line">0</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">57.5</span><br></pre></td></tr></table></figure>

<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>There are 3 cows at positions 7, 0, and 100. Installation of a base station of power r costs 20 + 5*r.The optimal solution is to build a base station at position 3.5 (with power 3.5) and another at position 100 (with power 0). The first base station covers cows 1 and 2, and the second covers cow 3.</p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>说FJ有n头奶牛，奶牛之间靠WIFI联系，WIFI可以向左右奶牛传递信号， 设WIFI有效半径为r，则安装一台WIFI的代价是 A + B * r，其中A，B均为常数，现在给出各个奶牛之间的位置，可设置WIFI的数量任意，问满足WIFI覆盖所有奶牛的最小花费是多少?</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先看见熟悉的2e3范围，能想到二层循环不会超时，自然向着dp的方向思考。</p>
<p>对于每次安装WIFI，仅仅有两种情况：</p>
<ol>
<li><p>直接给该位置的奶牛放置WIFI 其花费为A</p>
</li>
<li><p>在某两头奶牛之间设置WIFI，其花费为 A + B *L/2  （这两头牛的距离） ; </p>
<p>很明显可以知道不可能在已经覆盖WIFI的范围内再放置WIFI，那么上述两种子问题分解完毕。 </p>
<p>那么很明显，只需要二层循环枚举哪两头牛之间需要放置WIFI即可。 </p>
<p>设dp[i] = 表示前i-1头牛全覆盖付出的最小代价 </p>
<p>那么右边界要达到n+1 ，左边界为2</p>
<p>dp[i] = min(dp[i]  , dp[j] + 2 * A + B * (a[i-1] - a[j]));</p>
<p>由于本题会有/2导致出现小数0.5不好计算的情况，</p>
<p>故对状态转移方程进行 *2 处理 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n , a , b ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll ;</span><br><span class="line">ll p[<span class="number">2010</span>] ;</span><br><span class="line"><span class="function">ll <span class="title">min</span><span class="params">(ll x, ll y )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y? x : y ;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">2010</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;a,&amp;b) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++ )<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,p + i ) ;</span><br><span class="line">    std::<span class="built_in">sort</span>(p +<span class="number">1</span> , p + <span class="number">1</span> + n) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n + <span class="number">1</span> ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">0x3f3f3f3f3f3f3f3f</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; j ++ )</span><br><span class="line">        &#123;<span class="comment">//p[i-1] - p[j]实际上蕴含了给第i-1头牛单独装WIFI的情况</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i],dp[j] +<span class="number">2</span> * a + b * (p[i- <span class="number">1</span>] - p[j])) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span>(dp[n+<span class="number">1</span>]%<span class="number">2</span> == <span class="number">1</span> )<span class="built_in">printf</span>(<span class="string">&quot;%lld.5\n&quot;</span>,dp[n+<span class="number">1</span>]/<span class="number">2</span> ) ;<span class="comment">//这里对*2进行了一番处理</span></span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n+<span class="number">1</span>]/<span class="number">2</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="本题总结"><a href="#本题总结" class="headerlink" title="本题总结"></a>本题总结</h4><p>本题的小数点问题让我想不出dp的思路，实际上其小数点有且仅有0.5  ；</p>
<p>进行特殊处理即可用int类型进行运算。</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Weed -DP</title>
    <url>/2021/07/22/21-08-16/</url>
    <content><![CDATA[<h4 id="题目描述-WEED"><a href="#题目描述-WEED" class="headerlink" title="题目描述                                WEED"></a>题目描述                                WEED</h4><p>Takahashi’s and Aoki’s garden is covered with N weeds, called Weed 1, Weed 2, …, Weed N. The height of Weed i is Ai. Takahashi and Aoki have decided to pull these weeds, as follows:</p>
<ul>
<li><p>First, Aoki will choose at most K weeds and pull them.</p>
</li>
<li><p>Then, Takahashi will repeat the following operation until all weeds are pulled.</p>
</li>
<li><ul>
<li>Let H be the height of the tallest remaining weeds. Pull all weeds with heights above H/2 at once.</li>
</ul>
</li>
</ul>
<p>Aoki wants to minimize the number of operations done by Takahashi. Also, he wants to minimize it by pulling the minimum number of weeds needed. Find the number of operations done by Takahashi and the number of weeds Aoki pulls in this case.</p>
<p>Constraints<br>1≤N≤2×105<br>0≤K≤N<br>1≤Ai≤109<br>All values in input are integers.</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>Input is given from Standard Input in the following format:<br>N K<br>A1 A2 … AN</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Print the number of operations Takahashi will do and the number of weeds Aoki will pull, in this order, with a space in between.</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【样例1】</span><br><span class="line">4 1</span><br><span class="line">2 3 4 9</span><br><span class="line">【样例2】</span><br><span class="line">3 3</span><br><span class="line">2 3 5</span><br><span class="line">【样例3】</span><br><span class="line">9 8</span><br><span class="line">137 55 56 60 27 28 133 56 55</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【样例1】</span><br><span class="line">2 1</span><br><span class="line">【样例2】</span><br><span class="line">0 3</span><br><span class="line">【样例3】</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure>

<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>样例1解释：<br>For example, assume that Aoki chooses Weed 4, with height 9, and pulls it. Then, the tallest remaining weed is Weed 3, with height 4. We have 4/2=2, and Takahashi will pull Weed 2 and 3 in the first operation, since 2&lt;3 and 2&lt;4. Then, he will pull Weed 1 in the second operation, completing his work in two operations. On the other hand, he will not complete his work in one operation, no matter which one weed Aoki chooses.<br>Also, if Aoki pulls no weed, Takahashi will have to do three operations, so Aoki must pull at least one weed to minimize the number of operations done by Takahashi.</p>
<p>样例2解释：<br>If Aoki pulls all weeds, Takahashi has to do zero operations, which is obviously the smallest number possible.</p>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>话说庭院里面长满了各种杂草，Tak和Aok想要把草拔完，然而由于出题人的恶意只能AOk先拔去一部分草（不超过k个）剩下的杂草由Tak重复如下操作，将目前高度高于目前最高杂草高度一半的杂草全部拔完（高于H/2一律拔完）直到所有的草都被拔干净，然而AOK怜香惜玉，不希望Tak深陷芳草无法自拔，想要Tak能尽可能少的拔草，同时AOK也尽可能少拔草.</p>
<p>第一行给定有N和k</p>
<p>第二行给定有n个数字代表杂草的高度.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>假若AOK不开局拔草，那么所有的草都要由Tak操作，而每次操作会除去h/2以上高度的杂草，换言之Tak最多操作log a次 即在整形范围内大约31次，那么显然这个次数是可以进行枚举的.我们对杂草按高度进行排序就能知道每次Tak进行除草都会对一个区间[h/2,h]操作，各个区间无法相交，在指定操作次数下，在区间外面的杂草就是AOK所需要拔除的，而知道区间的右边就一定能找到区间的左边，因此我们设出dp[i] [j] 表示在Tak操作为j次的条件下，拔除前 i 棵草 Aok 所需要的最小操作次数，状态转移方程<br>$$<br>dp[i][j] = min(dp[i - 1][j] + 1,dp[pos_i - 1][j-1])<br>$$<br>对于第i棵草，若该草是AOK所拔，则+1即可，若AOK没有拔第i棵草，那么</p>
<p>只能由操作j-1次时由Tak拔除，这里的pos_i是第高于第i棵草高度一半的第一棵草的下标，通过二分查找可以以log n的效率将pos找到，于是最终代码如下。</p>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="keyword">int</span> n, k, a[<span class="number">200000</span>+<span class="number">5</span>] ;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">200000</span>+<span class="number">5</span>][<span class="number">40</span>] ;</span><br><span class="line"><span class="keyword">int</span> ans1 = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> ans2 = ans1 ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y )</span></span>&#123;<span class="keyword">return</span> x &lt; y ? x : y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(key &gt;= a[mid])</span><br><span class="line"></span><br><span class="line">		  l = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp)) ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; i ++ )</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a +  i) ;</span><br><span class="line">    <span class="built_in">sort</span>( a + <span class="number">1</span>,  a + <span class="number">1</span>  + n ) ;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]= <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++ )&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = i ;</span><br><span class="line">    <span class="keyword">int</span>  p = <span class="built_in">upper_bound</span>( a[i] &gt;&gt; <span class="number">1</span> )  ;<span class="comment">//利用函数找到该草的坐标.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">31</span> ; j ++ )&#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j] + <span class="number">1</span> ) ;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span>)dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[p - <span class="number">1</span>][j - <span class="number">1</span> ]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">31</span> ; i ++ )&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[n][i] &lt;= k  &amp;&amp; i &lt; ans1)ans1 = i, ans2 = dp[n][i] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dp[n][i] &lt;= k &amp;&amp; i == ans1)</span><br><span class="line">    ans2 = <span class="built_in">min</span>(ans2,dp[n][i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可知总效率在nloga范围内</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>colorful slimes(DP)</title>
    <url>/2021/04/04/22-56-07/</url>
    <content><![CDATA[<p>题目描述<br>Snuke lives in another world, where slimes are real creatures and kept by some people. Slimes come in N colors. Those colors are conveniently numbered 1 through N. Snuke currently has no slime. His objective is to have slimes of all the colors together.</p>
<p>Snuke can perform the following two actions:</p>
<p>Select a color i (1≤i≤N), such that he does not currently have a slime in color i, and catch a slime in color i. This action takes him ai seconds.</p>
<p>Cast a spell, which changes the color of all the slimes that he currently has. The color of a slime in color i (1≤i≤N−1) will become color i+1, and the color of a slime in color N will become color 1. This action takes him x seconds.</p>
<p>Find the minimum time that Snuke needs to have slimes in all N colors.</p>
<p>Constraints<br>2≤N≤2,000<br>ai are integers.<br>1≤ai≤109<br>x is an integer.<br>1≤x≤109<br>输入<br>The input is given from Standard Input in the following format:</p>
<p>N x<br>a1 a2 … aN<br>输出<br>Find the minimum time that Snuke needs to have slimes in all N colors.<br>样例输入 Copy<br>2 10<br>1 100<br>样例输出 Copy<br>12<br>提示<br>Snuke can act as follows:</p>
<p>Catch a slime in color 1. This takes 1 second.<br>Cast the spell. The color of the slime changes: 1 → 2. This takes 10 seconds.<br>Catch a slime in color 1. This takes 1 second.<br>本题大意是Snuke 想要获得N种颜色，他有两种操作，一是直接付出对应颜色的代价来获得，二是所有获得的颜色i变成颜色i + 1。<br>所以想要获得颜色i 有两种方法<br>1.直接付出相应代价。<br>2.进行操作二j次使 i-j（已经获得）变成 i 。<br>不妨设进行操作二的次数为j，显然想要以最小的代价获得全部的颜色，只需要最多n-1次操作二即可。<br>于是有 0 &lt;= j &lt;= n - 1 。<br>我们发现进行操作二的次数最终会在总代价上加上 j * x，<br>不妨设dp[ i ] [ j ]表示进行j次操作时获得第i个颜色的最小代价。<br>于是可以通过枚举j来获得操作次数为j时获得每种颜色付出的最小代价，最终加和即可。<br>状态转移方程 dp[ i ] [ j ] = min ( a[ i - j ] , dp [ i ] [ j - 1 ])<br>a[i - j ] 表示在获得第i个颜色时进行了第j次操作（已经做了j - 1 次）并以后移了j次的代价获得，<br>dp[ i ] [ j - 1 ] 表示在获得第i个颜色时（已经进行了j-1次操作），以当前代价直接获得。<br>下面贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span>`</span></span><br><span class="line">`<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>`</span></span><br><span class="line">`<span class="keyword">using</span> <span class="keyword">namespace</span> std;`</span><br><span class="line">`<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll ;`</span><br><span class="line"></span><br><span class="line">`<span class="keyword">int</span> dp[<span class="number">2020</span>][<span class="number">2020</span>];`</span><br><span class="line">`ll mi = <span class="number">0x3f3f3f3f3f3f3f3f</span> ;`</span><br><span class="line">`int main()`</span><br><span class="line">`&#123;`</span><br><span class="line">`ll n , x ,sum;`</span><br><span class="line">`<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;x) ;`</span><br><span class="line">`<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++)`</span><br><span class="line">`<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;dp[i][<span class="number">0</span>]) ;<span class="comment">//这里进行了空间优化，直接用dp[i][0] 表示a[i]即可 。` </span></span><br><span class="line">`<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++)`</span><br><span class="line">`<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n - <span class="number">1</span> ; j ++)&#123;`</span><br><span class="line">        `<span class="keyword">int</span> k = i - j ;`</span><br><span class="line">        `<span class="keyword">if</span>(k &lt;=<span class="number">0</span>) k += n  ;<span class="comment">//指向后移j次的代价可能会循环`</span></span><br><span class="line">        `dp[i][j] = <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[k][<span class="number">0</span>]) ;`</span><br><span class="line">    `&#125;`</span><br><span class="line">`<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n - <span class="number">1</span>; i ++)&#123;`</span><br><span class="line">        `sum = <span class="number">0</span> ;`</span><br><span class="line">        `<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; j ++)`</span><br><span class="line">            `sum += dp[j][i] ;`</span><br><span class="line">            `sum += i * x ;<span class="comment">//最后求得各个状态付出代价总和`</span></span><br><span class="line">            `mi = <span class="built_in">min</span>(mi,sum) ;<span class="comment">//取得其中的最小值`</span></span><br><span class="line">    `&#125;`</span><br><span class="line">`<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,mi) ;`</span><br><span class="line">`<span class="keyword">return</span> <span class="number">0</span> ；` </span><br><span class="line">`&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/29/20-24-16/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>one of each</title>
    <url>/2021/04/09/23-26-21/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>You are given a sequence of n integers x = [x1,x2,…,xn] and an integer k . It is guaranteed that 1 ≤ xi ≤ k , and every integer from 1 to k appears in the list x at least once.<br>Find the lexicographically smallest subsequence of x that contains each integer from 1 to k exactly once. </p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>The first line of input contains two integers n and k ( 1 ≤ k ≤ n ≤ 2 ∙105), where n is the size of the sequence, and the sequence consists only of integers from 1 to k .<br>Each of the next n lines contains a single integer xi( 1 ≤ xi ≤ k ). These are the values of the sequence X in order. It is guaranteed that every value from 1 to k will appear at least once in the sequence X . </p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>Output a sequence of integers on a single line, separated by spaces. This is the lexicographically smallest subsequence of X that contains every value from 1 to k. </p>
<h4 id="样例输入-Copy"><a href="#样例输入-Copy" class="headerlink" title="样例输入 Copy"></a>样例输入 <a href="javascript:CopyToClipboard($('#sampleinput').text())">Copy</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【样例1】</span><br><span class="line">6 3 </span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">【样例2】</span><br><span class="line">10 5</span><br><span class="line">5 </span><br><span class="line">4 </span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">1 </span><br><span class="line">4 </span><br><span class="line">1 </span><br><span class="line">1 </span><br><span class="line">5 </span><br><span class="line">5 </span><br></pre></td></tr></table></figure>

<h4 id="样例输出-Copy"><a href="#样例输出-Copy" class="headerlink" title="样例输出 Copy"></a>样例输出 <a href="javascript:CopyToClipboard($('#sampleoutput').text())">Copy</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【样例1】</span><br><span class="line">2 1 3 </span><br><span class="line">【样例2】</span><br><span class="line">3 2 1 4 5 </span><br></pre></td></tr></table></figure>

<p>本题大意为给定一段只包含1<del>k的一段数字序列，求从包含1</del>k的字典序最小序列 。 </p>
<p>要保证序列都含有1~k 的数字，若当前数字有且仅有一个并且栈内没有该数字，直接压入栈即可，若当前数字有多个且下一个数字比它小，直接弹出栈顶的元素，压入新元素入栈即可，最后倒序输出略有麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200000</span>+<span class="number">6</span>] ;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">200000</span>+<span class="number">6</span>] ;<span class="comment">//由于数据不大，用num记录各个数字的数量</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">200000</span>+<span class="number">6</span>] ;<span class="comment">//用vis 记录该数字是否在栈内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n ,  k ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k) ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a + i ) ;</span><br><span class="line">       num[a[i]] ++ ;</span><br><span class="line"> &#125;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;cnm ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )&#123;</span><br><span class="line">    num[a[i]] -- ;</span><br><span class="line">    <span class="keyword">if</span>(!vis[a[i]])&#123;<span class="comment">//当且仅当栈内没有该元素时考虑入栈</span></span><br><span class="line">        vis[a[i]]  = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(!cnm.<span class="built_in">empty</span>()&amp;&amp;num[cnm.<span class="built_in">top</span>()] &amp;&amp; cnm.<span class="built_in">top</span>() &gt; a[i])&#123;<span class="comment">//弹出比它大又需要放在后面的元素</span></span><br><span class="line">            vis[cnm.<span class="built_in">top</span>()] = <span class="number">0</span> ;</span><br><span class="line">            cnm.<span class="built_in">pop</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnm.<span class="built_in">push</span>(a[i])  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[k+<span class="number">5</span>] ;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(!cnm.<span class="built_in">empty</span>())&#123;<span class="comment">//这里将栈内元素倒序输出</span></span><br><span class="line">ans[p ++ ] = cnm.<span class="built_in">top</span>() ;</span><br><span class="line">cnm.<span class="built_in">pop</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = p - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i --)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]) ;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本题给的数据量仅仅允许o（n），所以考虑使用方便的数据结构！</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>传球游戏</title>
    <url>/2021/04/21/22-26-50/</url>
    <content><![CDATA[<h4 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>上体育课时，墨老师经常带着同学们一起做游戏。这次，墨老师带着同学们一起做传球游戏，游戏规则是这样的：N个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时拿着球没传出去的那个同学就是败者，要给大家表演一个节目。</p>
<p>聪明的张琪曼提出一个有趣的问题：有多少种不同的传球方法可以使得从张琪曼手里开始传的球，传了Ｍ次以后，又回到张琪曼手里。两种传球的方法被称作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设张琪曼为1号，球传了3次回到张琪曼手里的方式有1à2à3à1和1à3à2à1，共两种。</p>
<p>  <strong>【题目大意】</strong></p>
<p>同学之间有序编号，围成一个环，给定传球次数，问从一号开始传球，最终传回给一号有多少种方案。</p>
<h4 id="【解题思路】"><a href="#【解题思路】" class="headerlink" title="【解题思路】"></a><strong>【解题思路】</strong></h4><p><del>本题是一道披着搜索皮的动态规划题。</del></p>
<p>对于一个人传球，他只能传给周围的两个人</p>
<p>设dp[i] [j]表示球到第i个人手中，还能传j次球的方案总数</p>
<p>则状态转移方程dp[i] [j] = dp[i-1] [j-1] + dp[i+1] [j - 1 ] ; </p>
<p>有着动态规划的形式，却没有动态规划的最优决策，本题实质是搜索+剪枝</p>
<h4 id="【参考代码】"><a href="#【参考代码】" class="headerlink" title="【参考代码】"></a><strong>【参考代码】</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n , m ;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">40</span>][<span class="number">40</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[a][b] != <span class="number">-1</span> )<span class="keyword">return</span> dp[a][b] ;<span class="comment">//利用已经搜索过的dp[a][b]节省时间</span></span><br><span class="line">    <span class="keyword">if</span>(a &gt; n) a = <span class="number">1</span> ;<span class="comment">//这两行对越界的处理</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">1</span>) a = n ;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span> )&#123;<span class="comment">//没有传球机会了</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span> )<span class="keyword">return</span> <span class="number">1</span> ;<span class="comment">//某种方式传球到了1手中，返回1表示多了一种</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[a][b] = <span class="built_in">dfs</span>(a<span class="number">-1</span>,b<span class="number">-1</span>) +<span class="built_in">dfs</span>(a + <span class="number">1</span> ,b <span class="number">-1</span> ) ;<span class="comment">//给dp[a][b]赋值的同时进行搜索，最后返回dp[a][b] 的 值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp)) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,m)) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="本题总结"><a href="#本题总结" class="headerlink" title="本题总结"></a>本题总结</h4><p>本题重点需要理解函数dfs中最终return 一个等式的含义。赋值的同时返回该值，而所赋的值又需要搜索的过程。</p>
]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>大数乘积取模详解</title>
    <url>/2021/03/31/20-06-38/</url>
    <content><![CDATA[<p>对于给定三个数 a ，b  ,  mod .</p>
<p>求a * b模mod，</p>
<p>一般情况的最优策略是</p>
<p> ((a % mod) * (b %mod)) % mod </p>
<p><u>当a ， b ，mod 都很大的时候</u></p>
<p><u>还是会爆long long int(主要是mod太大)</u></p>
<p>这个时候正确的思路将a或者b拆解成不同部分乘积求和</p>
<p>类比快速幂的原理。</p>
<p>举个实例：求 3 * 15 对mod取模</p>
<p>将15 转化为二进制数1111</p>
<p>那么问题就转化为 3 * (1111)(2) %mod</p>
<p>分解1111得到</p>
<p>3 * (1 * 2^3 + 1* 2^2 + 1* 2^1 + 1*2^0)%mod </p>
<p>那么事实上我们只需将其各部分乘积分别取模，最后求和再取模即可。</p>
<p>下面贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  ll;</span><br><span class="line"><span class="function">ll <span class="title">mod_mult</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= mod;<span class="comment">//先降低a，b的规模</span></span><br><span class="line">    b %= mod;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)<span class="comment">//判断b的最后一位是否为1,是1就加是0就不加嘛</span></span><br><span class="line">         &#123;</span><br><span class="line">            ans += a;<span class="comment">//我们让ans加上a，其实实现了括号内的加法操作</span></span><br><span class="line">            ans%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;<span class="comment">//将a乘以2，这就是括号外面的a与括号内2的倍数的乘积</span></span><br><span class="line">        a%=mod;<span class="comment">//并且将a不断取模</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;<span class="comment">//让b的二进制数向右移动一位，即b/2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ll  a,b,mod;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;a,&amp;b,&amp;mod) ; </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">mod_mult</span>(a,b,mod)) ;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>我自认为已经讲得非常详细啦，为了优化运行速度使用了位运算，不熟悉位运算的小伙伴可以去了解一下哦。</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>取模</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构学习笔记</title>
    <url>/2021/05/07/19-59-18/</url>
    <content><![CDATA[<h1 id="数据结构学习笔记"><a href="#数据结构学习笔记" class="headerlink" title="数据结构学习笔记"></a>数据结构学习笔记</h1><h2 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h2><h3 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h3><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>1.根据某个关键字，查找记录</p>
<p>2.静态查找：集合中的记录是固定的只有查找，没有插入和删除操作</p>
<p>3.动态查找：查找的过程中可能有插入和删除</p>
<h4 id="静态查找："><a href="#静态查找：" class="headerlink" title="静态查找："></a>静态查找：</h4><p>1.顺序查找（on）</p>
<p>2.二分查找</p>
<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h3><p>n个结点构成的有限集合，n = 0 为空树</p>
<p>子树是不相交的；</p>
<p>除了根结点外，每个结点有且仅有一个父结点</p>
<p>用r表示树最上面的结点</p>
<p>树是保证结点连通的最小连通方式</p>
<h4 id="术语："><a href="#术语：" class="headerlink" title="术语："></a>术语：</h4><p>1.结点的度：结点的子树的个数DEGREE</p>
<p>2.树的度：所有结点最大的度数</p>
<p>3.叶结点：度为0的结点</p>
<p>4.父节点，子结点，兄弟结点</p>
<p>5.路径和路径长度：结点n1到nk含边的个数</p>
<p>6.祖先 结点，某子树的根结点</p>
<p>7.子孙结点</p>
<p>8.结点层次</p>
<p>9.树的高度</p>
<h3 id="3-树的表示："><a href="#3-树的表示：" class="headerlink" title="3.树的表示："></a>3.树的表示：</h3><p>儿子兄弟表示法：仅仅存储结点的第一个子结点和下一个兄弟结点</p>
<p>实战：</p>
<p>给定有0 到 n-1个结点</p>
<p>输入各个结点的信息：id ， k（结点度数即有几个子结点），子结点</p>
<p>输出各个结点的信息，父节点，深度，子结点集合，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL -1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> parent ;<span class="comment">//父结点还有左子右边兄弟</span></span><br><span class="line">    <span class="keyword">int</span> leftson ;</span><br><span class="line">    <span class="keyword">int</span> rightbro ;</span><br><span class="line">&#125;;</span><br><span class="line">Node T[MAX] ;</span><br><span class="line"><span class="keyword">int</span> n , D[MAX] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> u )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i , c ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;node %d : parent = %d , depth = %d ,&quot;</span>,u,T[u].parent,D[u]) ;</span><br><span class="line">    <span class="keyword">if</span>(T[u].parent == NIL)<span class="built_in">printf</span>(<span class="string">&quot;root [ &quot;</span>) ;<span class="comment">//如果父结点是- 1，表明这是根结点 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(T[u].leftson == NIL)<span class="built_in">printf</span>(<span class="string">&quot;leaf[&quot;</span>) ;<span class="comment">//没有左子结点表明这是叶结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;internal node [ &quot;</span>) ;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>  , c =  T[u].leftson; c != NIL; i ++,c = T[c].rightbro)<span class="comment">//找左儿子的所有右边兄弟</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i) <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;]&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec</span> <span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> p )</span><span class="comment">//递归找到结点的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D[u] = p ;<span class="comment">//p记录深度</span></span><br><span class="line">    <span class="keyword">if</span>(T[u].rightbro!= NIL)<span class="built_in">rec</span>(T[u].rightbro,p) ;</span><br><span class="line">    <span class="keyword">if</span>(T[u].leftson != NIL)<span class="built_in">rec</span>(T[u].leftson,p + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d , v , c , l, r ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">    T[i].parent = T[i].leftson = T[i].rightbro= NIL ;<span class="comment">//全初始化为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v,&amp;d) ;<span class="comment">//输入一个父结点v及其度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt; d ; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c) ;<span class="comment">//输入子结点</span></span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span> ) T[v].leftson = c ;<span class="comment">//第一个是其左儿子</span></span><br><span class="line">            <span class="keyword">else</span> T[l].rightbro = c ;<span class="comment">//记录左儿子的右边兄弟</span></span><br><span class="line">            l = c ;</span><br><span class="line">            T[c].parent = v ;<span class="comment">//记录其父结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ; i &lt; n ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i].parent == NIL) r = i ;<span class="comment">//找到根</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rec</span> (r,<span class="number">0</span>) ;<span class="comment">//根的深度为0 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;n ; i ++ )<span class="built_in">print</span>(i) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>即二叉树链表的实现方法，二叉树是树结构研究的重点。</p>
<h3 id="4-二叉树：度为2的树"><a href="#4-二叉树：度为2的树" class="headerlink" title="4.二叉树：度为2的树"></a>4.二叉树：度为2的树</h3><p>其子树有左右之分</p>
<h4 id="斜二叉树"><a href="#斜二叉树" class="headerlink" title="斜二叉树"></a>斜二叉树</h4><p>偏左偏右</p>
<h4 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h4><p>每个结点都有两个子结点</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><h4 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h4><p>1.第i层最多有2^(i-1)个结点</p>
<p>2.深度为k的二叉树最多有2^(k) - 1个结点</p>
<p>3.叶结点的数为a,度为2的非叶结点的个数为b，那么a = b + 1</p>
<h3 id="对二叉树的操作："><a href="#对二叉树的操作：" class="headerlink" title="对二叉树的操作："></a>对二叉树的操作：</h3><h3 id="1-判断是否为空"><a href="#1-判断是否为空" class="headerlink" title="1.判断是否为空"></a>1.判断是否为空</h3><h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h3><h4 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h4><p>先根然后左右子树</p>
<h4 id="2-后序遍历"><a href="#2-后序遍历" class="headerlink" title="2.后序遍历"></a>2.后序遍历</h4><p>先子树后根</p>
<h4 id="3-中序遍历"><a href="#3-中序遍历" class="headerlink" title="3.中序遍历"></a>3.中序遍历</h4><p>左根右</p>
<h4 id="4-层次遍历"><a href="#4-层次遍历" class="headerlink" title="4.层次遍历"></a>4.层次遍历</h4><p>按深度</p>
<h4 id="3-创建二叉树"><a href="#3-创建二叉树" class="headerlink" title="3.创建二叉树"></a>3.创建二叉树</h4><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1.顺序存储结构"></a>1.顺序存储结构</h4><p>从上到下，从左到右</p>
<p>非根结点的父节点的序号是i/2</p>
<p>结点i的左子结点是2*i，右子结点是2 * i +  1</p>
<p>适用于完全二叉树</p>
<p>特殊二叉树可能会产生空间浪费</p>
<h4 id="2-链表存储"><a href="#2-链表存储" class="headerlink" title="2.链表存储"></a>2.链表存储</h4><p>实战：</p>
<p>给定有0 到 n-1个结点</p>
<p>输入各个结点的信息：id ， k（结点度数即有几个子结点），子结点</p>
<p>输出各个结点的信息，父节点，深度，子结点集合，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>求1到n内所有数因子的和</title>
    <url>/2021/04/05/20-35-53/</url>
    <content><![CDATA[<p>求 1 ~ n范围内 各个数因子的和，数论中给出了如下结论 ：</p>
<p>n * ( 1 / 1 + 1/2 + 1/3 + …… + 1/ n) ; </p>
<p>原来在1到n中，1可以作为 n/ 1个数的因子 ； </p>
<p>2 可以作为 n / 2 个数的因子 ； </p>
<p>3可以作为 n / 3 个数的因子；</p>
<p>由此得出上面式子</p>
<p>将每个部分视为n / x</p>
<p>可知可以降低范围到√n</p>
<p>下面贴代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(l=<span class="number">1</span>; l&lt;=t; l++)</span><br><span class="line">            ans += n/l;</span><br><span class="line">    ans = ans*<span class="number">2</span>-t*t;<span class="comment">//其中t * t &lt;= n</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<p>这里贴出另一种代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LL l, r;</span><br><span class="line">   LL ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>( l = <span class="number">1</span>; l &lt;= n; l = r+<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       r = n/(n/l);</span><br><span class="line">       ans += n/l *(r - l + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果旅游（DP）</title>
    <url>/2021/04/02/21-16-33/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>xiaoT发现山谷相当的大，准确地说应该是相当的长，xiaoT想到山谷的那头去看看，但是靠xiaoT走路的速度，到那边要n年。还好xiaoT可以买一些苹果，它把这些苹果当成动力，根据火箭发射的原理，如果xiaoT把苹果向后扔，xiaoT就会向前进。</p>
<p>苹果有两种，一种青苹果，一种红苹果。<br>已知到山谷的长度为k，用一些（同一种类）苹果可以通过的路程为1。<br>苹果的价格是不一样的，红苹果的价格是红苹果个数的四次方。<br>青苹果的价格就是青苹果个数。</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行有一个正整数n表示xiaoT走路到那边需要的时间。<br>第二行有一个正整数k表示山谷的长度。<br>接下来k行，每行两个正整数，分别表示通过该段：<br>如果使用红苹果，则需要的数量为a<br>如果使用青苹果，则需要的数量为b</p>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出只有一个数，买苹果的最少的花费。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2296</span><br><span class="line">3</span><br><span class="line">3 1000</span><br><span class="line">2 5000</span><br><span class="line">4 8000</span><br></pre></td></tr></table></figure>

<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2296</span><br></pre></td></tr></table></figure>

<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>样例解释<br>第1段用青苹果，第2、3段用红苹果，花费是1000+(2+4)4</p>
<p>对于30%的数据，k≤10<br>对于50%的数据，k≤25<br>对于100%的数据，k≤50<br>对于100%的数据，每段路消耗的红苹果的数量≤10<br>对于100%的数据，每段路消耗的青苹果的数量≤107</p>
<p>题目大意是给定有k段路，每段路可以选择使用对应量的青苹果或者红苹果通过，使用青苹果付出的代价就是青苹果的数量，使用红苹果的代价是最终红苹果数量的4次方。</p>
<p><u>通过读题不难知道正整数n对本题结果完全没有影响，属于没有用的变量。</u></p>
<p>由给定的k范围可知若枚举每一段路，时间复杂度能够达到2^50，这个显然不合适</p>
<p>通过经验判断，这是一道dp题。</p>
<p>最终红苹果需要付出的代价取决于其最终的数量。也就是说我们不能在递推的过程中直接得出当时付出的代价，但是青苹果的数量即为付出的代价，换言之我们可以<u>通过枚举红苹果的数量，最终得到最少的青苹果数量来获得红苹果数量一定时的最小总代价。</u></p>
<p>不妨设dp[i] [j] 表示<u><strong>当红苹果数量为   j   时，前   i   段路中使用青苹果的最小数量。</strong></u></p>
<p>不妨用a[i]  , b[i]分别表示第i段路所需要的红苹果和青苹果的数量 。 </p>
<p>当 j  &lt;  a[i] 时，此时红苹果数量为  j ，可知经过第 i 段路一定没有选择红苹果 ，即：</p>
<p>dp[i] [j] = dp[i-1] [j] + b[i] ; </p>
<p>当j  &gt;= a[i] 时，那就有两种情况，一种是红苹果数量为j时没有选择 a[i] ,而是选择了青苹果即：</p>
<p>dp[i] [j] = dp[i- 1] [j] + b[i] ; </p>
<p>若此时选择了a[i] ,则dp[i] [j] = dp[i-1] [j-a[i]] ; </p>
<p>可知状态转移方程 dp[i] [j] = min (dp[i-1] [j] + b[i] , dp[i-1] [j-a[i]]) </p>
<p>最终枚举红苹果的数量，加上递推终点的青苹果数量即可。</p>
<p>那么下面贴AC代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll ;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x  ,<span class="keyword">long</span> <span class="keyword">long</span>  <span class="keyword">int</span> y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y ;</span><br><span class="line">&#125;</span><br><span class="line">ll dp[<span class="number">55</span>][<span class="number">505</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t) ;</span><br><span class="line">    <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k) ;</span><br><span class="line">    ll a[k+<span class="number">5</span>],b[k+<span class="number">5</span>] ;</span><br><span class="line">    ll sum = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i &lt;= k ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,a+i,b+i) ;</span><br><span class="line">        sum += a[i] ;<span class="comment">//记录红苹果最大的数量用以枚举</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span> ; i &lt;= k ; i ++ )</span><br><span class="line">    <span class="keyword">for</span>(ll j = sum ; j &gt;= <span class="number">0</span> ; j --)</span><br><span class="line">    &#123;   <span class="keyword">if</span>(j  &lt; a[i])</span><br><span class="line">          dp[i][j] = dp[i<span class="number">-1</span>][j] + b[i] ;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(j &gt;= a[i])</span><br><span class="line">          dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j] + b[i],dp[i<span class="number">-1</span>][j-a[i]]) ;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ll mi = <span class="number">0x3f3f3f3f</span> ;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span> ;  i&lt;= sum ; i ++ )</span><br><span class="line">    mi = <span class="built_in">min</span>(mi,dp[k][i] + i * i * i * i ) ;<span class="comment">//找到最小可能值即可</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,mi) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>马走日</title>
    <url>/2021/04/16/23-10-37/</url>
    <content><![CDATA[<h4 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>马在中国象棋以日字形规则移动。</p>
<p>请编写一段程序，给定n*m大小的棋盘，以及马的初始位置(x，y)，要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。</p>
<h4 id="【输入】"><a href="#【输入】" class="headerlink" title="【输入】"></a>【输入】</h4><p>第一行为整数T(T &lt; 10)，表示测试数据组数。<br>每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标n,m,x,y。(0&lt;=x&lt;=n-1,0&lt;=y&lt;=m-1, m &lt; 10, n &lt; 10)</p>
<h4 id="【输出】"><a href="#【输出】" class="headerlink" title="【输出】"></a>【输出】</h4><p>每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，0为无法遍历一次。</p>
<table>
<thead>
<tr>
<th align="left">输入</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>1 5 4 0 0 </code></td>
<td align="left"><code>32 </code></td>
</tr>
<tr>
<td align="left"><code>3 5 5 0 4 5 5 4 1 5 5 0 3 </code></td>
<td align="left"><code>304 0 0 </code></td>
</tr>
</tbody></table>
<p>遍历整个棋盘优选DFS，刚开始我还想着走完还要再扫一遍看看走完没，实际上只需要判断步数就行了，因为dfs肯定不会走走过的路线，当步数等于 n * m 时就结束搜索即可。当然这里面有回溯法的思想 。 </p>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">int</span> n , m ;</span><br><span class="line"><span class="keyword">int</span> sx,sy ;</span><br><span class="line"><span class="keyword">int</span> chessboard[<span class="number">20</span>][<span class="number">20</span>] ;<span class="comment">//建立合适大小的棋盘</span></span><br><span class="line"><span class="keyword">int</span> mov[<span class="number">9</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x ,<span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;n  &amp;&amp; y &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; chessboard[x][y] == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y ,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step == n * m )ans ++ ;<span class="comment">//合适就计数器加1 </span></span><br><span class="line">    <span class="keyword">int</span> nx , ny ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ;  i++ )&#123;</span><br><span class="line">        nx  = x + mov[i][<span class="number">0</span>] ;</span><br><span class="line">        ny  = y + mov[i][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">judge</span>(nx,ny))&#123;</span><br><span class="line">            chessboard[nx][ny] = <span class="number">1</span> ;</span><br><span class="line">            <span class="built_in">dfs</span>(nx,ny,step + <span class="number">1</span> ) ;</span><br><span class="line">            chessboard[nx][ny] = <span class="number">0</span> ;<span class="comment">//回溯。假装没有走过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t) ;</span><br><span class="line">    <span class="keyword">while</span>(t -- )&#123;</span><br><span class="line">         ans = <span class="number">0</span> ;</span><br><span class="line">         <span class="built_in">memset</span>(chessboard,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(chessboard)) ;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;sx,&amp;sy) ;</span><br><span class="line">         chessboard[sx][sy] = <span class="number">1</span> ;</span><br><span class="line">         <span class="built_in">dfs</span>(sx,sy,<span class="number">1</span>) ;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题总结</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher算法</title>
    <url>/2021/04/07/20-30-05/</url>
    <content><![CDATA[<p>Manacher 算法 ，用以求解最长回文字符串，其时间复杂度为o（n）,</p>
<p>这个算法首先最帅的一点在于对奇偶字符串的处理，例如aba和abba，那么仅仅需要在每个字符之间（包括外层）插入一个原字符串没有的字符，一般用“#”或者“$”，此时aba变成了：</p>
<p>#a#b#a# <strong>仍是以b为中心的奇数长度回文字符串</strong></p>
<p>此时abba变成了：</p>
<p>#a#b#b#a#<strong>这是其变成了以“#”为中心的奇数长度回文字符串</strong></p>
<p>有了以上的处理就可以将奇偶字符串统一拓展为奇数长度字符串进行处理。</p>
<p>但是manacher 算法中对字符串的处理还要进行防止越界处理（具体原因见下文处理）</p>
<p>比如对abba字符串的处理（注意下标）</p>
<p>a    b    b    a  其下标为：</p>
<p>0    1    2    3预处理后的字符串</p>
<p>   @#a#b#b#a#$ 其下标为</p>
<p>   0 1 23456789 10 </p>
<p>1.我们处理过的要用的字符串从下标从1 开始</p>
<p>2.为防止越界要在新字符串下标为0的位置 和字符串的末尾添加两个原来串没有又不同的字符</p>
<p>我这里用的就是@ 和 $</p>
<p>下面贴预处理的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    newstr[<span class="number">0</span>] = <span class="string">&#x27;@&#x27;</span> ; </span><br><span class="line">    newstr[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span> ; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        newstr[<span class="number">2</span>*i + <span class="number">2</span> ] = str[i] ; </span><br><span class="line">        newstr[<span class="number">2</span>*i + <span class="number">3</span> ] = <span class="string">&#x27;#&#x27;</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    newstr[<span class="number">2</span> * len + <span class="number">2</span> ] = <span class="string">&#x27;$&#x27;</span> ; </span><br><span class="line">    <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就预处理完毕了，接下来是该最精彩的部分 ； </p>
<p>用一个数组 r [i] 记录 以newstr[i]为中心的最长回文串的半径长度  </p>
<p><strong>r[i]数组是马拉车算法的核心！！！！</strong></p>
<p>用 maxid 记录 在位置 i 以前的回文串右边能延伸到的最大位置</p>
<p>即maxid = id  + r[id] ; </p>
<p>id 即对应maxid</p>
<p>注意这个id 不是 i 而是之前某个位置的下标 ！ </p>
<p>然后就用了动态规划的思想以o（n）的复杂度更新了所有的newstr[i] 对应的r[i] ; </p>
<p>接下来先看代码!</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> id , maxid = <span class="number">0</span> ; </span><br><span class="line">   len = <span class="number">2</span> * len + <span class="number">2</span> ； </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(maxid &gt; i )</span><br><span class="line">   r[i] = <span class="built_in">min</span>(r[<span class="number">2</span> * id - i] , maxid - i ) ; </span><br><span class="line">   <span class="keyword">else</span> r[i] = <span class="number">1</span> ; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(newstr[i + r[i]] == newstr[i - r[i]])</span><br><span class="line">         r[i] ++ ; </span><br><span class="line">   <span class="keyword">if</span>( r[i] + i &gt; maxid)</span><br><span class="line">   &#123;</span><br><span class="line">       maxid = r[i] + i ;</span><br><span class="line">       id = i ; </span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看看动态规划更新r[i]的核心部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(maxid &gt; i )</span><br><span class="line">   r[i] = <span class="built_in">min</span>(r[<span class="number">2</span> * id - i] , maxid - i ) ; </span><br><span class="line">   <span class="keyword">else</span> r[i] = <span class="number">1</span> ; </span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p><img src="data:image/png;base64,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" alt="image"></p>
<p>如上图由 已知可以知道 j = 6 , i  = 14 , maxid  = mi  = 17  , id = 10  ;</p>
<p>可以明显看出r[i] = 4    ，即11到i</p>
<p>r[j] = 6 ; 即j 到11</p>
<p>j 是i 关于id对称位置的下标</p>
<p>并且有j = 2 * id - i  ; </p>
<p>根据对称原理可知</p>
<p>若newstr[j]处有回文串 ， 则其对称位置newstr[i]处最大回文串半径r[i] = r[j] ; </p>
<p>如上图这里j处对称过来的回文串长度 加上i的坐标显然超过了mi 即 maxid  ，这时r[i]只需要取mi - i 即可</p>
<p>即有状态转移方程 r[i] = min(r[j] , maxid - i) ; </p>
<p>即上面核心代码maxid &gt; i的部分</p>
<p>若maxid &lt; i，很显然在 i 并不在回文串id -maxid 到id + maxid内，此时newstr[i]只能跟自己构成回文串了，故r[i] = 1 ; 然后是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(newstr[i + r[i]] == newstr[i - r[i]])</span><br><span class="line">       r[i] ++ ; </span><br></pre></td></tr></table></figure>

<p>直接更新位置i处的回文串半径，不再赘述。</p>
<p>最后有</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(newstr[i + r[i]] == newstr[i - r[i]])</span><br><span class="line">        r[i] ++ ; </span><br><span class="line">  <span class="keyword">if</span>( r[i] + i &gt; maxid)</span><br><span class="line">  &#123;</span><br><span class="line">      maxid = r[i] + i ;</span><br><span class="line">      id = i ; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如上文所述 maxid为i前回文串向后延伸的最远位置 ，若i处向后延伸的回文串还能更远，那么更新</p>
<p>maxid ，这时候id 就更新为 i 。</p>
<p><strong>经过如上面的一轮循环，我们就找到了字符串中关于每个位置i的最大回文串半径r[i] ！！！！</strong></p>
<p>设L[i]为x新字符串中以newstr[i]为中心的<strong>最长回文串长度</strong></p>
<p>那么显然有 L[i]  = 2 * r[i] - 1 </p>
<p>容易知道 L[i]的长度总为奇数字符串的长度</p>
<p>对于两种字符串 #a#b#a#或#a#a#</p>
<p><strong>其对应的回文串长度（L -1）/2 即为原来的字符串长度！</strong></p>
<p><strong>该值为r[i] - 1</strong>    ！！！</p>
<p>那么想要找到这一个字符串中最长的回文串的长度，不断更新r[i] - 1的最大值即可！！</p>
<p>于是用来求最长回文串长度的代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">int</span> max_len = <span class="number">0</span> ; </span><br><span class="line">   <span class="keyword">int</span> id , maxid = <span class="number">0</span> ; </span><br><span class="line">   len = <span class="number">2</span> * len + <span class="number">2</span> ； </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">if</span>(maxid &gt; i )</span><br><span class="line">   r[i] = <span class="built_in">min</span>(r[<span class="number">2</span> * id - i] , maxid - i ) ; </span><br><span class="line">   <span class="keyword">else</span> r[i] = <span class="number">1</span> ; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(newstr[i + r[i]] == newstr[i - r[i]])</span><br><span class="line">         r[i] ++ ; </span><br><span class="line">   <span class="keyword">if</span>( r[i] + i &gt; maxid)</span><br><span class="line">   &#123;</span><br><span class="line">       maxid = r[i] + i ;</span><br><span class="line">       id = i ; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   max_len = <span class="built_in">max</span>(max_len,r[i] - <span class="number">1</span> );</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,max_len) ; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是马拉车算法的教程，有一说一马老先生是真的NB！</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
</search>
